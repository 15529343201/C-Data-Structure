/*2013年计算机联考真题:已知一个整数序列A=(a0,a1,...,an-1),其中0<=ai<n(0<=i<n)。若存在ap1=ap2=...=apm=x
且m>n/2(0<=pk<n,1<=k<=m),则称x为A的主元素。例如A=(0,5,5,3,5,7,5,5),则5为主元素;又如A=(0,5,5,3,5,1,5,7),
则A中没有主元素。假设A中的n个元素保存在一个一维数组中,请设计一个尽可能高效的算法,找出A的主元素。若存在
主元素,则输出该元素;否则输出-1。要求:
  (1)给出算法的基本设计思想
     算法的策略是从前向后扫描数组元素,标记出一个可能成为主元素的元素Num。然后重新计数,确认Num是否是主元素。
	 算法可分为以下两步:
	   1)选取候选的主元素:依次扫描所给数组中的每个整数,将第一个遇到的整数Num保存到c中,记录Num出现的次数
	     为1;若遇到的下一个整数仍等于Num,则计数加1,否则计数减1;当计数减到0时,将遇到的下一个整数保存到c
		 中,计数重新记为1,开始新一轮计数,即从当前位置开始重复上述过程,直到扫描完全部数组元素。
	   2)判断c中元素是否是真正的主元素:再次扫描该数组,统计c中元素出现的次数,若大于n/2,则为主元素;否则,
	     序列中不存在主元素。 
  (2)根据设计思想,采用C或C++或java语言描述算法,关键之处给出注释
  (3)说明你所设计算法的时间复杂度和空间复杂度
  	 实现的程序的时间复杂度为O(n),空间复杂度为O(1) 
*/
//主元素:给定一个整型数组，找出主元素，它在数组中的出现次数严格大于数组元素个数的二分之一。
#include<stdio.h>
int Majority(int A[],int n){  //0,5,5,3,5,7,5,5
	int i,c,count=1;  //c用来保存候选主元素,count用来计数
	c=A[0];           //设置A[0]为候选主元素
	for(i=1;i<n;i++){ //查找候选主元素 
		if(A[i]==c)
			count++;  //对A中的候选主元素计数       count=2 count=2 count=3
		else
			if(count>0)  //处理不是候选主元素的情况
				count--;                            //count=0 count=0 count=1
			else{        //更换候选主元素,重新计数 
				c=A[i];                             //c=A[2]=5
				count=1;                            //count=1
			} 
	}
	if(count>0)
 		for(i=count=0;i<n;i++) //统计候选主元素的实际出现次数
		 	if(A[i]==c)  //c=5
			 	count++;
			if(count>n/2)
				return c;      //确认候选主元素
			else
				return -1;     //不存在主元素 
}

int main(void){
	int A[]={0,5,5,3,5,7,5,5};
	int B[]={0,5,5,3,5,1,5,7};
	printf("%d\n",Majority(A,8));
	printf("%d\n",Majority(B,8));
	return 0;
}

/*
5
-1
*/
